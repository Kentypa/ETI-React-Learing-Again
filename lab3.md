# Контрольні запитання

1. Що таке "підняття стану" (lifting state up) і чому ми використовуємо його для SearchBar?  
   Підняття стану — це перенесення стану з дочірнього компонента у батьківський, щоб кілька компонентів могли спільно використовувати одні й ті самі дані. У випадку з SearchBar ми піднімаємо стан введеного значення у HomeComponent, щоб саме він керував логікою пошуку та фільтрації постів. Це дозволяє SearchBar бути лише контролем вводу, а вся бізнес-логіка залишається у батьківському компоненті.

2. Поясніть асинхронну природу оновлення стану в useState.  
   useState не оновлює значення миттєво. React групує кілька оновлень стану та виконує їх асинхронно для оптимізації продуктивності. Тому після виклику setState нове значення буде доступне лише при наступному рендері компонента, а не одразу в тій самій функції.

3. Чому для фільтрації ми створюємо нову змінну filteredPosts, а не змінюємо оригінальний масив postsData у стані?  
   postsData є джерелом даних (immutable). Ми не змінюємо його напряму, щоб уникнути побічних ефектів та зберегти можливість повторного використання оригінальних даних. Створення нового масиву (filteredPosts) гарантує чистоту функцій та передбачуваність роботи програми.

4. У чому перевага використання керованих компонентів над некерованими при реалізації пошуку?  
   Керовані компоненти зберігають значення у стані React, що дозволяє централізовано керувати даними, синхронізувати їх з іншими частинами застосунку та легко реалізовувати логіку (наприклад, пошук і фільтрацію). Некеровані компоненти покладаються на DOM, що ускладнює контроль та тестування.

# Вимоги до звіту

## Фрагмент коду з логікою роботи пошуку

```tsx
<SearchBar
  onChange={(event) => setSearchQuery(event.target.value)}
  value={searchQuery}
  name="search"
/>
```

## Фрагмент коду з логікою фільтрації

```tsx
const filteredPosts: PostType[] = postsData.filter((post) => {
  const matchesText =
    post.content.toLowerCase().includes(searchQuery.toLowerCase()) ||
    post.tag.toLowerCase().includes(searchQuery.toLowerCase());

  const matchesCategory =
    activeCategory === "All" || post.tag === activeCategory;

  return matchesText && matchesCategory;
});
```

## Пояснення, як реалізовано обробку "порожнього результату" Якщо жоден пост не відповідає введеному тегу, filter() поверне порожній масив, і список <ul> буде пустим. Для користувача можна додати повідомлення:

```tsx
<ul className="flex flex-col gap-4 border-2 p-4 rounded-md w-full max-w-xl">
  {filteredPosts.length === 0 ? (
    <p>No posts found</p>
  ) : (
    filteredPosts.map((post) => (
      <li key={post.id}>
        <Post {...post} />
      </li>
    ))
  )}
</ul>
```
